/**
 ** Copyright 2016 General Electric Company
 **
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
 ** You may obtain a copy of the License at
 ** 
 **     http://www.apache.org/licenses/LICENSE-2.0
 ** 
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */


package com.ge.research.semtk.belmont;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.UUID;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import com.ge.research.semtk.belmont.BelmontUtil;
import com.ge.research.semtk.belmont.Node;
import com.ge.research.semtk.belmont.NodeGroup;
import com.ge.research.semtk.belmont.NodeItem;
import com.ge.research.semtk.belmont.PropertyItem;
import com.ge.research.semtk.belmont.AutoGeneratedQueryTypes;
import com.ge.research.semtk.belmont.Returnable;
import com.ge.research.semtk.load.utility.UriResolver;
import com.ge.research.semtk.ontologyTools.ClassException;
import com.ge.research.semtk.ontologyTools.OntologyClass;
import com.ge.research.semtk.ontologyTools.OntologyInfo;
import com.ge.research.semtk.ontologyTools.OntologyName;
import com.ge.research.semtk.ontologyTools.OntologyPath;
import com.ge.research.semtk.ontologyTools.OntologyProperty;
import com.ge.research.semtk.ontologyTools.PathException;
import com.ge.research.semtk.ontologyTools.TimeoutException;

public class NodeGroup {
	
	// actually used to keep track of our nodes and the nomenclature in use. 
	private HashMap<String, String> sparqlNameHash = null;
	private ArrayList<Node> nodes = new ArrayList<Node>();
	public ArrayList<Node> orphanOnCreate = new ArrayList<Node>();
	
	public NodeGroup(){
		this.sparqlNameHash = new HashMap<String, String>();
	}
	
	/**
	 * Create a NodeGroup from JSON
	 */
	public static NodeGroup getInstanceFromJson(JSONObject json) throws Exception{
		NodeGroup nodegroup = new NodeGroup();
		nodegroup.addJsonEncodedNodeGroup(json);
		return nodegroup;
	}
	
	/**
	 * Create a NodeGroup from the (JSON) results of a CONSTRUCT query.
	 * @param jobj the output of a SPARQL construct query (assume key is @graph)
	 * @return a NodeGroup containing the construct query results
	 * @throws Exception 
	 */
	public static NodeGroup fromConstructJSON(JSONObject jobj) throws Exception{
				
		if(jobj == null){
			throw new Exception("Cannot create NodeGroup from null JSON object");
		}		
		
		// get the contents of @graph
		JSONArray nodeArr = (JSONArray) jobj.get("@graph");  
		if(nodeArr == null){
			throw new Exception("No @graph key found when trying to create node group from construct query");
		}

		NodeGroup nodeGroup = new NodeGroup();		
		HashMap<String,Node> nodeHash = new HashMap<String,Node>(); // maps node URI to Node
		
		// first pass - gather each node's id, type, and primitive properties (but skip its properties that are node items)
		for (int i = 0; i < nodeArr.size(); i++) {
			
			JSONObject nodeJson = (JSONObject) nodeArr.get(i);	
			// e.g. sample nodeJSON:
			// {
			//	"@id":"http:\/\/research.ge.com\/sofc\/data#Cell_EHAP298",
			//	"@type":[{"@id":"http:\/\/research.ge.com\/sofc\/testconfig#Cell"}],  ... IN VIRTUOSO 7.2.5+, NO @id HERE
			//	"http:\/\/research.ge.com\/sofc\/testconfig#cellId":[{"@value":"EHAP298","@type":"http:\/\/www.w3.org\/2001\/XMLSchema#string"}],
			//	"http:\/\/research.ge.com\/sofc\/testconfig#screenPrinting":[{"@id":"http:\/\/research.ge.com\/sofc\/data#ScrnPrnt_EHAP298_Barrier_2015-06-12"}],
			//	"http:\/\/research.ge.com\/sofc\/testconfig#sizeInches":[2]
			//	}
			
			// gather basic node info
			String instanceURI = nodeJson.get("@id").toString();  // node id
						
			// this format differs between Virtuoso 7.2 and 7.2.5.  Support both.
			String classURI;
			Object typeEntry0 = (((JSONArray)nodeJson.get("@type"))).get(0);
			if(typeEntry0 instanceof JSONObject && ((JSONObject)typeEntry0).containsKey("@id")){
				classURI = ((JSONObject)typeEntry0).get("@id").toString(); // "@type" : [ { "@id": "http://research.ge.com/energy/turbineeng/configuration#TestType"} ]  (in Virtuoso 7.2)
			}else{
				classURI = typeEntry0.toString(); // "@type" : [ "http://research.ge.com/energy/turbineeng/configuration#TestType" ] }   (in Virtuoso 7.2.5+)
			}						
			String name = (new OntologyName(classURI)).getLocalName();									
			
			// create the Node and add it to the NodeGroup
			Node node = new Node(name, null, null, classURI, nodeGroup); 
			node.setInstanceValue(instanceURI);		
			nodeHash.put(instanceURI, node); 				// add node to node hash
			nodeGroup.addOneNode(node, null, null, null);	// add node to node group
						
			ArrayList<PropertyItem> properties = new ArrayList<PropertyItem>();
			Iterator<String> keysItr = (Iterator<String>) nodeJson.keySet().iterator();
		    while(keysItr.hasNext()) {
		    			    	
		        String key = keysItr.next();
		        Object value = nodeJson.get(key);		        
		        if(key.equals("@id") || key.equals("@type")){
		        	continue;  // already got node id and type above, so skip
		        }		        
		        		        
		        // primitive properties are like this:
		        // e.g. KEY=http://research.ge.com/sofc/testconfig#pasteMaterial VALUE=[{"@value":"Ce0.8Sm0.2 Oxide Paste","@type":"http:\/\/www.w3.org\/2001\/XMLSchema#string"} {"@value":"Another Paste","@type":"http:\/\/www.w3.org\/2001\/XMLSchema#string"}]
		        		         
		        JSONArray valueArray = (JSONArray)value; 	// the value is an array
	        	if(!((JSONObject)((valueArray).get(0))).containsKey("@type")){  // check the first element - if no @type then this is not a primitive property   
	        		continue;  
	        	}		        
	        	
		        PropertyItem property = null;
		        for(int j = 0; j < valueArray.size(); j++){ 
		        	JSONObject valueJSONObject = (JSONObject)((valueArray).get(j));	 
		        	if(property == null){  // only create property once
		        		String relationship = key; 		// e.g. http://research.ge.com/sofc/testconfig#pasteMaterial
		        		String propertyValueType = valueJSONObject.get("@type").toString();	// e.g. http://www.w3.org/2001/XMLSchema#string
		        		String relationshipLocal = new OntologyName(relationship).getLocalName();   // e.g. pasteMaterial
		        		String propertyValueTypeLocal = new OntologyName(propertyValueType).getLocalName();	// e.g. string
		        		property = new PropertyItem(relationshipLocal, propertyValueTypeLocal, propertyValueType, relationship); 		        		
		        	}
		        	String propertyValue = valueJSONObject.get("@value").toString();  // e.g. Ce0.8Sm0.2 Oxide Paste
		        	property.addInstanceValue(propertyValue);		        
		        }	
		        property.setIsReturned(true);	// note - Javascript had this inside the for loop
		        properties.add(property);		// note - Javascript had this inside the for loop
		    }
		    node.setProperties(properties);  // add the properties to the node		    
		}
		

		// second pass - gather properties that are links to other nodes
		// this can only be done after all of the nodes are created		
		for (int i = 0; i < nodeArr.size(); i++) {
			
			JSONObject nodeJson = (JSONObject) nodeArr.get(i);	
		    
			// this is the node to link from - retrieve it from the hash
        	String fromNodeURI = nodeJson.get("@id").toString(); 
        	Node fromNode = nodeHash.get(fromNodeURI);  	        
			
			ArrayList<NodeItem> nodeItems = new ArrayList<NodeItem>();
		    Iterator<String> keysItr = (Iterator<String>) nodeJson.keySet().iterator();
		    while(keysItr.hasNext()) {
		    			    	
		        String key = keysItr.next();
		        Object value = nodeJson.get(key);		        		        
		        if(key.equals("@id") || key.equals("@type")){
		        	continue;  // already got node id and type above, so skip
		        }		        

		        // node items are in this format:
		        // e.g. KEY=http://research.ge.com/sofc/testconfig#screenPrinting VALUE=[{"@id":"http:\/\/research.ge.com\/sofc\/data#ScrnPrnt_EHAP298_Barrier_2015-06-12"}]        		        
		        
		        JSONArray valueArray = (JSONArray)value; 	// the value is an array
	        	if(((JSONObject)((valueArray).get(0))).containsKey("@type")){  // check the first element - if has @type then this is not a node item
	        		continue;  
	        	}
		        
		        NodeItem nodeItem = null;
		        for(int j = 0; j < valueArray.size(); j++){
		        	JSONObject valueJSONObject = ((JSONObject)(valueArray).get(j));	// the value is an array 	      		        

			        String relationship = key;  // e.g. http://research.ge.com/sofc/testconfig#screenPrinting
			        String relationshipLocal = (new OntologyName(relationship)).getLocalName(); // e.g. screenPrinting			        
		        	String toNodeURI = valueJSONObject.get("@id").toString(); // e.g. http://research.ge.com/sofc/data#ScrnPrnt_EHAP298
		        	String toNodeURILocal = (new OntologyName(toNodeURI)).getLocalName(); // e.g. ScrnPrnt_EHAP298
			        Node toNode = nodeHash.get(toNodeURI);  
			        String toNodeClassURI = toNode.getFullUriName(); // e.g. http://research.ge.com/sofc/testconfig#ScreenPrinting		        	
			        
		        	if(nodeItem == null){  // only create node item once
				        nodeItem = new NodeItem(relationshipLocal, (new OntologyName(toNodeClassURI)).getLocalName(), toNodeClassURI); 
				        nodeItem.setConnected(true);
			        	nodeItem.setConnectBy(relationshipLocal);
				        nodeItem.setUriConnectBy(relationship);				        
		        	}
		        	nodeItem.setNodes(toNode);  // add all instance values to it
		        }		  
				nodeItems.add(nodeItem);
		    }
		    fromNode.setNodeItems(nodeItems);	
		    
		    if(fromNode.getInstanceValue() != null){  // differs from javascript, may need to modify later
		    	fromNode.setIsReturned(true);  
		    }

		}		    		  
		
		return nodeGroup;
	}
	
	/**
	 * Use JSON fuctionality to implement deepCopy
	 * @param nodegroup
	 * @return a deep copy
	 * @throws Exception
	 */
	public static NodeGroup deepCopy(NodeGroup nodegroup) throws Exception {
		NodeGroup copy = new NodeGroup();
		copy.addJsonEncodedNodeGroup(nodegroup.toJson());
		return copy;
	}
	
	public void addJsonEncodedNodeGroup(JSONObject jobj) throws Exception{
		HashMap<String, String> changedHash = new HashMap<String, String>();
		this.resolveSparqlIdCollisions(jobj, changedHash);
		
		// attempt to add the nodes, using "changedHash" as a guide for IDs.
		this.addJson((JSONArray) jobj.get("sNodeList")); 
	}
	
	public void addJson(JSONArray nodeArr) throws Exception {
		for (int j = 0; j < nodeArr.size(); ++j) {
			JSONObject node = (JSONObject) nodeArr.get(j);
			
			Node curr  = new Node(node, this);
			Node check = this.getNodeBySparqlID(curr.getSparqlID());
			
			// create nodes we have never seen
			if(check == null){
				this.addOneNode(curr, null, null, null);
			}
			// modify the existing node:
			else{
				
				check = null;
				for(Node nd : this.orphanOnCreate){
					if(curr.sparqlID == nd.sparqlID){
						check = nd;
					}
				}
				if(check != null){
					check = new Node(node, this);
					this.addOneNode(check, null, null, null);
				}
				else{
					throw new Exception( "uncreated node referenced: " + curr.sparqlID );
				}
			}
			
		}
		this.orphanOnCreate.clear();
	}
	
	public ArrayList<Node> getNodeList(){
		return this.nodes;
	}
	
	public void addOneNode(Node curr, Node existingNode, String linkFromNewUri, String linkToNewUri) throws Exception {


		// reserve the node SparqlID
		this.reserveNodeSparqlIDs(curr);
		
		// add the node to the nodegroup control structure..
		this.nodes.add(curr);
		// set up the connection info so this node participates in the graph
		if(linkFromNewUri != null && linkFromNewUri != ""){
			curr.setConnection(existingNode, linkFromNewUri);
		}
		else if(linkToNewUri != null && linkToNewUri != ""){
			existingNode.setConnection(curr, linkToNewUri);
		}
		else{
			//no op
		}
		
	}

	private void reserveNodeSparqlIDs(Node curr) {
		String ID = curr.getSparqlID();
		if(this.sparqlNameHash.containsKey(ID)){	// this name was already used. 
			ID = BelmontUtil.generateSparqlID(ID, this.sparqlNameHash);
			curr.setSparqlID(ID);	// update it. 
		}
		this.reserveSparqlID(ID);	// actually hold the name now. 
		
		// check the properties...
		ArrayList<PropertyItem> props = curr.getReturnedPropertyItems();
		for(int i = 0; i < props.size(); i += 1){
			String pID = props.get(i).getSparqlID();
			if(this.sparqlNameHash.containsKey(pID)){
				pID = BelmontUtil.generateSparqlID(pID, this.sparqlNameHash);
				props.get(i).setSparqlID(pID);
			}
			this.reserveSparqlID(pID);
		}
		
	}

	public void reserveSparqlID(String id) {
		if (id != null && id.length() > 0) {
			this.sparqlNameHash.put(id, "1");
		}
	}

	public void freeSparqlID(String id) {
		// alert("retiring " + id);
		if (id != null && id.length() > 0) {
			this.sparqlNameHash.remove(id);
		}
	}

	private JSONObject resolveSparqlIdCollisions(JSONObject jobj, HashMap<String, String> changedHash) {
		// loop through a json object and resolve any SparqlID name collisions
		// with this node group.
		JSONObject retval = jobj;
		
		if(this.sparqlNameHash.isEmpty()){	// nothing to do.
			return retval;
		}
		
		// set up a temp hashMap to store the values. 
		HashMap<String, String> tempHash = new HashMap<String, String>();
		tempHash.putAll(this.sparqlNameHash);
		
		
		JSONArray nodeArr = (JSONArray)jobj.get("sNodeList");
		// loop through the nodes in the JSONArray
		for(int k = 0; k < nodeArr.size(); k += 1){
			JSONObject jnode = (JSONObject) nodeArr.get(k);
			
			jnode = BelmontUtil.updateSparqlIdsForJSON(jnode, "SparqlID", changedHash, tempHash);
			
			// iterate over property objects
			JSONArray propArr = (JSONArray) jnode.get("propList");
			
			for (int j = 0; j < propArr.size(); ++j) {
				JSONObject prop = (JSONObject) propArr.get(j);
				prop = BelmontUtil.updateSparqlIdsForJSON(prop, "SparqlID", changedHash, tempHash);
			}
			
			// and the node list			
			JSONArray nodeItemArr = (JSONArray) jnode.get("nodeList");
			
			for (int j = 0; j < nodeItemArr.size(); ++j) {
				JSONObject node = (JSONObject) nodeItemArr.get(j);
				JSONArray nodeConnections = (JSONArray)node.get("SnodeSparqlIDs");
				for(int m = 0; m < nodeConnections.size(); m += 1){
				// this should update the values we care about
					JSONArray nodeInst = (JSONArray)node.get("SnodeSparqlIDs");
					nodeInst = BelmontUtil.updateSparqlIdsForJSON(nodeConnections, k, changedHash, tempHash);
				}
			}
		}
		
		return retval;
	}
	
	/**
	 * 
	 * @param uri
	 * @return ArrayList of Nodes which are of class uri
	 */
	public ArrayList<Node> getNodesByURI(String uri) {
		// get all nodes with the given uri
		ArrayList<Node> ret = new ArrayList<Node>();

		for (int i = 0; i < this.nodes.size(); i++) {
			if (this.nodes.get(i).getUri().equals(uri)) {
				ret.add(this.nodes.get(i));
			}
		}
		return ret;
	}
	
	/**
	 * 
	 * @param uri
	 * @param oInfo
	 * @return ArrayList of Nodes which are of class uri or any of its subclasses
	 */
	public ArrayList<Node> getNodesBySuperclassURI(String uri, OntologyInfo oInfo) {
		// get all nodes with the given uri
		ArrayList<Node> ret = new ArrayList<Node>();

		// get all subclasses
		ArrayList<String> classes = new ArrayList<String>();
		classes.add(uri);
		classes.addAll(oInfo.getSubclassNames(uri));
		
		// for each class / sub-class
		for (int i=0; i < classes.size(); i++) {
			// get all nodes
			ArrayList<Node> c = this.getNodesByURI(classes.get(i));
			// push node if it isn't already in ret
			for (int j=0; j < c.size(); j++) {
				if (ret.indexOf(c.get(j)) == -1) {
					ret.add(c.get(j));
				}
			}
		}
		
		return ret;
	}
	
	public Node getNodeBySparqlID(String currId) {
		// look up a node by ID and return it. 
		Node retval = null;
		for(int i = 0; i < nodes.size(); i += 1){
			// can we find it by name?
			if(this.nodes.get(i).getSparqlID().equals(currId)){   // this was "==" but that failed in some cases...
				retval = this.nodes.get(i);
				break;
			}
		}
		return retval;
	}
	
	public String generateSparql(AutoGeneratedQueryTypes qt, Boolean allPropertiesOptional, Integer limit, Returnable targetObject) throws Exception{
		return this.generateSparql(qt, allPropertiesOptional, limit, targetObject, false);
	}

	public String generateSparql(AutoGeneratedQueryTypes qt, Boolean allPropertiesOptional, Integer limit, Returnable targetObject, Boolean keepTargetConstraints) throws Exception{
		String retval = "";
		
		if (nodes.size() == 0) {
			return retval;
		}
		
		StringBuilder sparql = new StringBuilder();
		ArrayList<Node> orderedNodes = this.getOrderedNodeList();
		
		if (qt.equals(AutoGeneratedQueryTypes.QUERY_COUNT)) {
			sparql.append("SELECT (COUNT(*) as ?count) { \n");
		}
		
		sparql.append("select distinct");
		
		if (targetObject != null) {
			sparql.append(" ").append(targetObject.getSparqlID());
		}
		else {
			for(Node n : orderedNodes) {
				if (n.getIsReturned()) {
					sparql.append(" ").append(n.getSparqlID());
				}
				
				ArrayList<PropertyItem> props = n.getReturnedPropertyItems();
				
				for (PropertyItem pi : props) {
					sparql.append(" ").append(pi.getSparqlID());
				}
			}
		}
		
		if (sparql.toString().equals("select distinct")) {
			throw new Exception("No values selected to return");
		}
		
		sparql.append(" where {\n");
		
		ArrayList<Node> headNodes = this.getHeadNodes();
		ArrayList<Node> completedNodes = new ArrayList<Node>();
		
		for (Node head : headNodes) {
			sparql.append(this.generateSparqlSubtreeClauses(qt, head, targetObject, completedNodes, "\t", allPropertiesOptional));
		}
		
		sparql.append("}\n");
		
		if (qt.equals(AutoGeneratedQueryTypes.QUERY_CONSTRAINT)) {
			// do nothing - may change in future
		}
		if (limit != null && limit > 0) {
			sparql.append(" LIMIT ").append(limit);
		}
		if (qt.equals(AutoGeneratedQueryTypes.QUERY_COUNT)) {
			sparql.append("\n}");
		}
		
		
		retval = BelmontUtil.prefixQuery(sparql.toString());
		
		return retval;
	}

	public String generateSparqlConstruct() throws Exception{
		// generate a sparql construct statement based off the node group. 
		
		// get the starting nodes and the collection to place nodes labeled completed. 
		ArrayList<Node> headNodes = this.getHeadNodes();
		ArrayList<Node> doneLeader = new ArrayList<Node>();
		ArrayList<Node> doneFooter = new ArrayList<Node>();
		
		String leader = "";
		String footer = "";
		// generate the basic pattern to search.
		for(Node hd : headNodes){
			leader += this.generateSparqlSubtreeClauses(AutoGeneratedQueryTypes.QUERY_CONSTRUCT, hd, null, doneLeader, "   ", false);
			footer += this.generateSparqlSubtreeClauses(AutoGeneratedQueryTypes.QUERY_CONSTRUCT_WHERE, hd, null, doneFooter, "   ", false);
		}
		String retval = "construct {\n" + leader + " } \n where {\n " + footer + " }\n "; 
		retval = BelmontUtil.prefixQuery(retval.toString());
		return retval;
	}
	
	public String generateSparqlAsk() throws Exception{
		// generate a sparql ask statement
		String footer = "";
		
		
		ArrayList<Node> headNodes = this.getHeadNodes();
		ArrayList<Node> completedNodes = new ArrayList<Node>();
		
		for (Node head : headNodes) {
			footer += this.generateSparqlSubtreeClauses(AutoGeneratedQueryTypes.QUERY_CONSTRUCT_WHERE, head, null, completedNodes, "\t", false);
		}
		
		
		String retval = "ask {\n" + footer + "\n}";
		retval = BelmontUtil.prefixQuery(retval.toString());
		return retval;
	}
	
	private String generateSparqlSubtreeClauses(AutoGeneratedQueryTypes qt, Node curr, Returnable targetObject, ArrayList<Node> completedNodes,
			String string, Boolean allPropertiesOptional) {
		StringBuilder sparql = new StringBuilder();
		
		// check to see if this node has already been processed. 
		if(completedNodes.contains(curr)){
			// nothing to do.
			return sparql.toString();
		}
		else{
			completedNodes.add(curr);
		}
		
		// use the type information to determine what to include. only really valid for construct
		if(qt == AutoGeneratedQueryTypes.QUERY_CONSTRUCT || qt == AutoGeneratedQueryTypes.QUERY_CONSTRUCT_WHERE){
			sparql.append("\t" + curr.getSparqlID() + " a " + curr.getSparqlID() + "_type .\n");
		}
		
		// generate sparql for properties and constraints.
		for(PropertyItem prop : curr.getReturnedPropertyItems()){
			// check for being optional...
			if(((allPropertiesOptional != null && allPropertiesOptional == true) || prop.getIsOptional()) && qt != AutoGeneratedQueryTypes.QUERY_CONSTRUCT){
				sparql.append("\t optional{\n");
			}
			
			// basic property sparql
			sparql.append("\t " + curr.getSparqlID() + " <" + prop.getUriRelationship() + "> " + prop.getSparqlID() +  " .\n");
		
			// get the attribute range and the constraints, if any. 
			if(prop.getConstraints() != null && prop.getConstraints() != ""){
				// make sure appying constraints is valid. it is not in all cases
				if((qt != AutoGeneratedQueryTypes.QUERY_CONSTRUCT) && (qt != AutoGeneratedQueryTypes.QUERY_CONSTRAINT || targetObject == null || prop.getSparqlID() != targetObject.getSparqlID())){
					if(prop.getConstraints() != null && !prop.getConstraints().equalsIgnoreCase("")){
						sparql.append("\t" + prop.getConstraints() + " .\n");
					}
				}
			}
			// close optional block.
			if(((allPropertiesOptional != null && allPropertiesOptional == true) || prop.getIsOptional()) && qt != AutoGeneratedQueryTypes.QUERY_CONSTRUCT){
				sparql.append("\t } \n");
			}
		}// end propertiy Items work.
		
		// add value constraints...
		if(! curr.getValueConstraintStr().isEmpty()){
			// add unless this is a constraint query on the target object
			if((qt != AutoGeneratedQueryTypes.QUERY_CONSTRUCT) && (qt != AutoGeneratedQueryTypes.QUERY_CONSTRAINT || curr != targetObject)){
				if(curr.getValueConstraintStr() != null && !curr.getValueConstraintStr().equalsIgnoreCase("")){
					sparql.append("\t" + curr.getValueConstraintStr() + ". \n");
				}
			}
		}
		
		// get type-constraining statement for any type that needs it. 
		sparql.append(this.generateSparqlTypeClause(curr));

		// recursive process of NodeItem subtree
		for(NodeItem ni : curr.getNodeItemList()){
			
			// open optional block, if that makes sense
			if(ni.getIsOptional() && ni.getNodeList().size() > 0 && qt != AutoGeneratedQueryTypes.QUERY_CONSTRUCT){
				sparql.append("\t optional {\n");
			}
			// add the nodeItem information
			for(Node domainNode : ni.getNodeList()){
				sparql.append("\t" + curr.getSparqlID() + " <" + ni.getUriConnectBy() + "> " + domainNode.getSparqlID() + " .\n");
				sparql.append(this.generateSparqlSubtreeClauses(qt, domainNode, targetObject, completedNodes, "    ", allPropertiesOptional));
			}
			// close optional block
			if(ni.getIsOptional() && ni.getNodeList().size() > 0 && qt != AutoGeneratedQueryTypes.QUERY_CONSTRUCT){
				sparql.append("}\n");
			}
		}
	
		return sparql.toString();
	}

	private String generateSparqlTypeClause(Node curr) {
		String retval = "";
		// Generates SPARQL to constrain the type of this node if
		// There is no edge that constrains it's type OR
		// the edge(s) that constrain it don't actually include it (they're all
		// super classes, so not enough constraint)
		
		ArrayList<String> constrainedTypes = this.getConnectedRange(curr);
		
		if(constrainedTypes.size() == 0 || !constrainedTypes.contains(curr.getFullUriName() )){
			// constrain to exactly the this type since there are no sub-types
			if(curr.getSubClassNames().size() == 0){
				retval += "\t " + curr.getSparqlID() + " a <" + curr.getFullUriName() + "> .\n";
			}
			else{
				retval += "\t" + curr.getSparqlID() + " a " + curr.getSparqlID() + "_type .\n";
				retval += "\t" + curr.getSparqlID() +  "_type " + " rdfs:subClassOf <" + curr.getFullUriName() + ">.\n";
			}
		}
		
		return retval;
	}

	private ArrayList<Node> getOrderedNodeList() throws Exception {
		ArrayList<Node> ret = new ArrayList<Node>();
		
		ArrayList<Node> headList = this.getHeadNodes();
		
		for (Node n : headList) {
			ret.add(n);
			ret.addAll(this.getSubNodes(n));
		}
		
		ArrayList<Node> ret2 = new ArrayList<Node>();
		Hashtable hash = new Hashtable();
		
		// remove duplicates from ret
		for (Node n : ret) {
			if (hash.get(n.getSparqlID()) == null) {
				ret2.add(n);
				hash.put(n.getSparqlID(), 1);
			}
		}
		
		return ret2;
	}
	
	public void pruneAllUnused () {
		// prune all unused subgraphs
		ArrayList<Node> pruned = new ArrayList<Node>();
		boolean prunedSomething = true;
		
		// continue until every node has been pruned
		while (prunedSomething) {
			// list is different each time, so start over to find first unpruned node
			prunedSomething = false;
			for (Node node : this.nodes) {
				if (!pruned.contains(node)) {
					pruned.add(node);
					this.pruneUnusedSubGraph(node);
					prunedSomething = true;
					break;   // go back to "while" since this.SNodeList is now changed
				}
			}
		} 
	}
	
	public boolean pruneUnusedSubGraph (Node node) {
		
		if (! node.isUsed()) {
			ArrayList<Node> subNodes = this.getAllConnectedNodes(node);
			ArrayList<ArrayList<Node>> subGraphs = new ArrayList<ArrayList<Node>>();
			ArrayList<Integer> needSubTree = new ArrayList<Integer>();
			int needSubTreeCount = 0;
			
			ArrayList<Node> stopList = new ArrayList<Node>();
			stopList.add(node);
			
			// build a subGraph for every connection
			for (int i = 0; i < subNodes.size(); i++) {
				subGraphs.set(i, this.getSubGraph(subNodes.get(i), stopList));
				needSubTree.set(i, 0);
				
				for (int j=0; j < subGraphs.get(i).size(); j++) {
					if (subGraphs.get(i).get(j).isUsed()) {
						needSubTree.set(i, 1);
						needSubTreeCount += 1;
						break;
					}
				}
				if (needSubTreeCount > 1) break;
			}
			
			// if only one subGraph has nodes that are constrained or returned
			if (needSubTreeCount < 2) {
				
				// delete any subGraph with no returned or constrained nodes
				for (int i=0; i < subGraphs.size(); i++) {
					if (needSubTree.get(i) == 0) {
						for (int j=0; j < subGraphs.get(i).size(); j++) {
							this.deleteNode(subGraphs.get(i).get(j), false);
						}
					}
				}
				
				// recursively walk up the 'needed' subtree
				// pruning off any unUsed nodes and subGraphs
				ArrayList<Node> connList = this.getAllConnectedNodes(node);
				this.deleteNode(node, false);
				for (int i=0; i < connList.size(); i++) {
					this.pruneUnusedSubGraph(connList.get(i));
				}
				
				return true;
			}
		}
		return false;
	}
	
	public void deleteNode (Node nd, boolean recurse) {
		ArrayList<String> sparqlIDsToRemove = new ArrayList<String>();
		ArrayList<Node> nodesToRemove = new ArrayList<Node>();
		
		// add the requested node
		nodesToRemove.add(nd);
		
		// if appropriate, get the children recursively.
		if (recurse) {
			ArrayList<Node> tempVal = this.getSubNodes(nd);
			nodesToRemove.addAll(tempVal);
		} else {
			// do nothing extra at all.
		}
		
		for (int j=0; j < nodesToRemove.size(); j++) {
			ArrayList<String> k = nodesToRemove.get(j).getSparqlIDList();
			sparqlIDsToRemove.addAll(k);
			// replaces tagging and removeTaggedNodes
			this.removeNode(nodesToRemove.get(j));
		}
		
		// free sparqlIDs
		for (int i = 0; i < sparqlIDsToRemove.size(); i++) {
			this.freeSparqlID(sparqlIDsToRemove.get(i));
		}
	}
	
	private void removeNode(Node node) {
		// replaces removeTaggedNodes:  only removes one specific node
		
		// remove the current sNode from all links.
		for (Node k : this.nodes) {
			k.removeFromNodeList(node);
		}
		
		// remove the sNode from the nodeGroup
		this.nodes.remove(node);
	}
	
	private ArrayList<Node> getSubGraph(Node startNode, ArrayList<Node> stopList) {
		ArrayList<Node> ret = new ArrayList<Node>();
		
		ret.add(startNode);
		ArrayList<Node> conn = this.getAllConnectedNodes(startNode);
		
		for (Node n : conn) {
			if (! stopList.contains(n) && ! ret.contains(n)) {
				ret.addAll(this.getSubGraph(n, ret));
			}
		}
		return ret;
	}
	
	public Node addPath(OntologyPath path, Node anchorNode, OntologyInfo oInfo ) throws Exception {
		return this.addPath(path, anchorNode, oInfo, false, false);
	}
	
	public Node addPath(OntologyPath path, Node anchorNode, OntologyInfo oInfo, Boolean reverseFlag) throws Exception {
		return this.addPath(path, anchorNode, oInfo, reverseFlag, false);
	}

	public Node addPath(OntologyPath path, Node anchorNode, OntologyInfo oInfo, Boolean reverseFlag, Boolean optionalFlag) throws Exception {
		// Adds a path to the canvas.
		// path start class is the new one
		// path end class already exists
		// return the node corresponding to the path's startClass. (i.e. the one
		// the user is adding.)
		
		// reverseFlag:  in diabolic case where path is one triple that starts and ends on same class
		//               if reverseFlag, then connect
		
		// add the first class in the path
		Node retNode = this.addNode(path.getStartClassName(), oInfo);
		Node lastNode = retNode;
		Node node0;
		Node node1;
		int pathLen = path.getLength();
		// loop through path but not the last one
		for (int i = 0; i < pathLen - 1; i++) {
			String class0Uri = path.getClass0Name(i);
			String attUri = path.getAttributeName(i);
			String class1Uri = path.getClass1Name(i);

			// if this hop in path is  lastAdded--hasX-->class1
			if (class0Uri.equals(lastNode.getUri())) {
				node1 = this.returnBelmontSemanticNode(class1Uri, oInfo);
				this.addOneNode(node1, lastNode, null, attUri);
				lastNode = node1;
				
				if (optionalFlag) {
					throw new Exception("Internal error in belmont.js:AddPath(): SparqlGraph is not smart enough\nto add an optional path with links pointing away from the new node.\nAdding path without optional flag.");
					//optionalFlag = false;
				}
			// else this hop in path is class0--hasX-->lastAdded
			} else {
				node0 = this.returnBelmontSemanticNode(class0Uri, oInfo);
				this.addOneNode(node0, lastNode, attUri, null);
				lastNode = node0;
			}
		}

		// link the last two nodes, which by now already exist
		String class0Uri = path.getClass0Name(pathLen - 1);
		String class1Uri = path.getClass1Name(pathLen - 1);
		String attUri = path.getAttributeName(pathLen - 1);

		// link diabolical case from anchor node to last node in path
		if (class0Uri.equals(class1Uri) && reverseFlag ) {
			anchorNode.setConnection(lastNode, attUri);
			if (optionalFlag) {
				throw new Exception("Internal error in belmont.js:AddPath(): SparqlGraph is not smart enough\nto add an optional path with links pointing away from the new node.\nAdding path without optional flag.");
			}
		// normal link from last node to anchor node
		} else if (anchorNode.getUri().equals(class1Uri)) {
			lastNode.setConnection(anchorNode, attUri);
			if (optionalFlag) {
				throw new Exception("Internal error in belmont.js:AddPath(): SparqlGraph is not smart enough\nto add an optional path with links pointing away from the new node.\nAdding path without optional flag.");
			}
		// normal link from anchor node to last node
		} else {
			NodeItem nodeItem = anchorNode.setConnection(lastNode, attUri);
			if (optionalFlag) {
				nodeItem.setIsOptional(true);
			}
		}
		return retNode;

	}
	
	public Node returnBelmontSemanticNode(String classUri, OntologyInfo oInfo) {
		// return a belmont semantic node represented by the class passed from
		// oInfo.
		// PAUL NOTE: this used to be in graphGlue.js
		// But there is no value in keeping oInfo and belmont separate, and
		// combining is elegant.
		OntologyClass oClass = oInfo.getClass(classUri);
		ArrayList<PropertyItem> belprops = new ArrayList<PropertyItem>();
		ArrayList<NodeItem> belnodes = new ArrayList<NodeItem>();

		// set the value for the node name:
		String nome = oClass.getNameString(true);
		String fullNome = oClass.getNameString(false);

		ArrayList<OntologyProperty> props = oInfo.getInheritedProperties(oClass);

		// get a list of the properties not repesenting other nodes.
		for (int i = 0; i < props.size(); i++) {
			String propNameLocal = props.get(i).getName().getLocalName();
			String propNameFull = props.get(i).getName().getFullName();
			String propRangeNameLocal = props.get(i).getRange().getLocalName();
			String propRangeNameFull = props.get(i).getRange().getFullName();

			// is the range a class ?
			if (oInfo.containsClass(propRangeNameFull)) {
				NodeItem p = new NodeItem(propNameLocal, propRangeNameLocal, propRangeNameFull);
				belnodes.add(p);

			}
			// range is string, int, etc.
			else {

				// create a new belmont property object and add it to the list.
				PropertyItem p = new PropertyItem(propNameLocal, propRangeNameLocal, propRangeNameFull, propNameFull);
				belprops.add(p);
			}
		}

		return new Node(nome, belprops, belnodes, fullNome, this);
	}
	
	public HashMap<String, String> getSparqlNameHash() {
		return sparqlNameHash;
	}

	/**
	 * Adds one node without making any connections
	 * @param classUri
	 * @param oInfo
	 * @return Node
	 * @throws Exception 
	 */
	public Node addNode(String classUri, OntologyInfo oInfo) throws Exception {
		Node node = this.returnBelmontSemanticNode(classUri, oInfo);
		this.addOneNode(node, null, null, null);
		return node;
	}
	
	public int getNodeCount() {
		return this.nodes.size();
	}
	
	private ArrayList<String> getArrayOfURINames() {
		ArrayList<String> retval = new ArrayList<String>();
		int t = this.nodes.size();
		for (int l = 0; l < t; l++) {
			// output the name
			retval.add(this.nodes.get(l).getUri());
			// alert(this.SNodeList[l].getURI());
		}
		return retval;

	}
	
	public String changeSparqlID(PropertyItem obj, String requestID) {
		// API call for any object with get/setSparqlID:
		// set an object's sparqlID, making sure it is legal, unique, nameHash,
		// etc...
		// return the new id, which may be slightly different than the requested
		// id.

		this.freeSparqlID(obj.getSparqlID());
		String newID = BelmontUtil.generateSparqlID(requestID, this.sparqlNameHash);
		this.reserveSparqlID(newID);
		obj.setSparqlID(newID);
		return newID;
	}
	
	public String changeSparqlID(Node obj, String requestID) {
		// API call for any object with get/setSparqlID:
		// set an object's sparqlID, making sure it is legal, unique, nameHash,
		// etc...
		// return the new id, which may be slightly different than the requested
		// id.

		this.freeSparqlID(obj.getSparqlID());
		String newID = BelmontUtil.generateSparqlID(requestID, this.sparqlNameHash);
		this.reserveSparqlID(newID);
		obj.setSparqlID(newID);
		return newID;
	}

	public Node addClassFirstPath(String classURI, OntologyInfo oInfo, String domain, Boolean optionalFlag) throws Exception {
		// attach a classURI using the first path found.
		// Error if less than one path is found.
		// return the new node
		// return null if there are no paths

		// get first path from classURI to this nodeGroup
		ArrayList<OntologyPath> paths = oInfo.findAllPaths(classURI, this.getArrayOfURINames(), domain);
		if (paths.size() == 0) {
			return null;
		}
		OntologyPath path = paths.get(0);
		
		// get first node matching anchor of first path
		ArrayList<Node> nlist = this.getNodesByURI(path.getAnchorClassName());
		
		// add sNode
		Node sNode = this.addPath(path, nlist.get(0), oInfo, false, optionalFlag);

		return sNode;
	}
	
	public Node getOrAddNode(String classURI, OntologyInfo oInfo, String domain) throws Exception {
		return this.getOrAddNode(classURI, oInfo, domain, false, false);
	}
	
	public Node getOrAddNode(String classURI, OntologyInfo oInfo, String domain, Boolean superclassFlag) throws Exception {
		return this.getOrAddNode(classURI, oInfo, domain, superclassFlag, false);
	}

	public Node getOrAddNode(String classURI, OntologyInfo oInfo, String domain, Boolean superclassFlag, Boolean optionalFlag ) throws Exception {
		// return first (randomly selected) node with this URI
		// if none exist then create one and add it using the shortest path (see addClassFirstPath)
		// if superclassFlag, then any subclass of classURI "counts"
		// if optOptionalFlag: ONLY if node is added, change first nodeItem connection in path's isOptional to true
		
		// if gNodeGroup is empty: simple add
		Node sNode;
		
		if (this.getNodeCount() == 0) {
			sNode = this.addNode(classURI, oInfo);
			
		} else {
			// if node already exists, return first one
			ArrayList<Node> sNodes = new ArrayList<Node>(); 
			
			// if superclassFlag, then any subclass of classURI "counts"
			if (superclassFlag) {
				sNodes = this.getNodesBySuperclassURI(classURI, oInfo);
			// otherwise find nodes with exact classURI
			} else {
				sNodes = this.getNodesByURI(classURI);
			}
			
			if (sNodes.size() > 0) {
				sNode = sNodes.get(0);
			} else {
				sNode = this.addClassFirstPath(classURI, oInfo, domain, optionalFlag);
			}
		}
		return sNode;
	}
	
	private ArrayList<Node> getAllConnectedNodes(Node node) {
		ArrayList<Node> ret = new ArrayList<Node>();
		ret.addAll(node.getConnectedNodes());
		ret.addAll(this.getConnectingNodes(node));
		return ret;
	}
	
	private ArrayList<Node> getConnectingNodes(Node node) {
		ArrayList<Node> ret = new ArrayList<Node>();
		for (Node n : this.nodes) {
			if (n.getConnectingNodeItems(node).size() > 0 ) {
				ret.add(n);
			}
		}
		return ret;
	}
	
	private ArrayList<Node> getSubNodes(Node topNode) {
		ArrayList<Node> subNodes = new ArrayList<Node>();
		
		ArrayList<Node> connectedNodes = topNode.getConnectedNodes();
		
		subNodes.addAll(connectedNodes);
		
		for (Node n : connectedNodes) {
			ArrayList<Node> innerSubNodes = this.getSubNodes(n);
			subNodes.addAll(innerSubNodes);
		}
		
		return subNodes;
	}
	
	private ArrayList<Node> getHeadNodes() throws Exception {
		ArrayList<Node> ret = new ArrayList<Node>();
		
		for (Node n : nodes) {
			int connCount = 0;
			for (Node o : nodes) {
				if (o.checkConnectedTo(n)) {
					++connCount;
					break;
				}
			}
			
			if (connCount == 0) {
				ret.add(n);
			}
		}
		
		if (!nodes.isEmpty() && ret.isEmpty()) {
			throw new Exception("Cyclic graph detected");
		}
		
		return ret;
	}
	
	private ArrayList<String> getConnectedRange(Node node) {
		ArrayList<String> retval = new ArrayList<String>();
		
		for (Node n : nodes) {
			ArrayList<NodeItem> nodeItems = n.getConnectingNodeItems(node);
			for (NodeItem ni : nodeItems) {
				String uriValueType = ni.getUriValueType();
				if (!retval.contains(uriValueType)) {
					retval.add(uriValueType);
				}
			}
		}
		
		return retval;
	}
	public String generateSparqlInsert(OntologyInfo oInfo) throws Exception{
		return this.generateSparqlInsert(null, oInfo);
	}
	
	public String generateSparqlInsert(String post, OntologyInfo oInfo) throws Exception{
		String retval = "";
		// get the primary insert body.
		String primaryBody = this.getInsertLeader(post, oInfo);
		
		// get the where clause body
		String whereBody = this.getInsertWhereBody(post, oInfo);
		
		retval = "INSERT {\n" + primaryBody + "} WHERE {" + whereBody + "}\n";
		
		try {
			String retvalClean = BelmontUtil.prefixQuery(retval);
			retval = retvalClean;
		} catch (Exception e) {
			throw new Exception("error encountered attempting to create prefixed insert query");
			
		}
		return retval;
	}

	public String getInsertLeader(String postfixSparqlIDs, OntologyInfo oInfo) {
		// this method creates the top section of the insert statements.
		// the single argument is used to post-fix the sparqlIDs, if required. 
		// this is used in the generation of bulk insertions. 
		String retval = "";
		if(postfixSparqlIDs == null){ postfixSparqlIDs = "";}
		
		// loop through the nodes and get any values we may need. 
		for(Node curr : this.nodes){
			
			Boolean currIsEnum = oInfo.classIsEnumeration(curr.getFullUriName());
			Boolean currInstanceBlank = false;
			String currInstanceValue = curr.getInstanceValue();
			
			if(currInstanceValue == null || currInstanceValue == "" || currInstanceValue.isEmpty()){
				currInstanceBlank = true;
			}

			String sparqlID = curr.getSparqlID() + postfixSparqlIDs;
			// makes sure to indicate that this node was of its own type. it comes up.
		
			/**
			 * There is a subtlety here where one can get into trouble if a node has no instance value (the instance uri)
			 * this comes in two flavors:
			 * 1. the node referenced is an enumeration and we should drop it. can't go inventing new ones just because
			 * 2. basically make a blank node because we need those one on the path. this one is interesting because we need to makes sure
			 *    there is an in or out edge to our unnamed node, or else we are just making clutter. 
			 *    
			 *    Note: for now, we are going to make the clutter. 
			 */
			
			// only add this node if the current instance should be included. 
			if((!currIsEnum) || (currIsEnum && !currInstanceBlank)){
				retval += "\t" + sparqlID + " a <" + curr.getFullUriName() + "> . \n";
				
				// insert each property we know of. 
				for(PropertyItem prop : curr.getPropertyItems()){
					for(String inst : prop.getInstanceValues()){
						retval += "\t" + sparqlID + " <" + prop.getUriRelationship() + "> \"" + inst + "\"^^<http://www.w3.org/2001/XMLSchema#" + prop.getValueType() + "> .\n";  
					}
				}
				
				// insert a line for each node item
				for(NodeItem ni : curr.getNodeItemList()){
					for(Node currentConnection : ni.getNodeList()){
						retval += "\t" + sparqlID + " <" + ni.getUriConnectBy() + "> " + currentConnection.getSparqlID() + postfixSparqlIDs + " .\n";
					}
				}
			}
		}
		
		return retval;
	}
	
	public String getInsertWhereBody(String postfixSparqlIDs, OntologyInfo oInfo) {
		StringBuilder sparql = new StringBuilder();
		
		if (postfixSparqlIDs == null) {
			postfixSparqlIDs = "";
		}
		
		for (Node node : this.nodes) {
			String sparqlId = node.getSparqlID() + postfixSparqlIDs;
			

			Boolean currIsEnum = oInfo.classIsEnumeration(node.getFullUriName());
			Boolean currInstanceBlank = false;
			String currInstanceValue = node.getInstanceValue();
			
			if(currInstanceValue == null || currInstanceValue == "" || currInstanceValue.isEmpty()){
				currInstanceBlank = true;
			}

			// node was specified
			if (!currInstanceBlank) {
				
				String nodeVal = node.getInstanceValue();
				
				if(!nodeVal.contains("#")){
					nodeVal = UriResolver.DEFAULT_URI_PREFIX + nodeVal;
				}
				
				sparql.append("\tBIND (<").append(nodeVal).append("> AS ")
					.append(sparqlId).append(").\n");
			}
			else if(currInstanceBlank && !currIsEnum){
				ArrayList<PropertyItem> constrainedProps = node.getConstrainedPropertyObjects();
				
				if (!constrainedProps.isEmpty()) {
					// node is constrained
					
					for (PropertyItem pi : constrainedProps) {
						sparql.append(" ").append(sparqlId).append(" <").append(pi.getUriRelationship())
							.append("> ").append(pi.getSparqlID()).append(". ").append(pi.getConstraints())
							.append(" .\n");
					}
				}
				
				else {
					// node not constrained, create new URI
					
					// create new instance
					// we have to be able to check if the Node has "instanceValue" set. if it does. we want to reuse that. if not, kill it.
					if (node.getInstanceValue() != null && !node.getInstanceValue().equals("") && !node.getInstanceValue().isEmpty()) {
						String nodeVal = node.getInstanceValue();
						if(!nodeVal.contains("#")){
							nodeVal = UriResolver.DEFAULT_URI_PREFIX + nodeVal;
						}
						
						sparql.append("\tBIND (iri(\"").append(nodeVal)
							.append("\") AS ").append(sparqlId).append(").\n");
					}
					else {
						sparql.append("\tBIND (iri(concat(\"" + UriResolver.DEFAULT_URI_PREFIX + "\", \"")
							.append(UUID.randomUUID().toString()).append("\")) AS ")
							.append(sparqlId).append(").\n");
					}
				}
			}
			
		}
		
		return sparql.toString();
	}

	@SuppressWarnings("unchecked")
	public JSONObject toJson() throws Exception {
		JSONObject ret = new JSONObject();
		
		// get list in order such that linked nodes always preceed the node that
		// links to them
		ArrayList<Node> orig = this.getOrderedNodeList();
		ArrayList<Node> snList = new ArrayList<Node>();
		for (int i = orig.size()-1; i >=0; i--) {
			snList.add(orig.get(i));
		}
		
		ret.put("version", 1);
		
		JSONArray sNodeList = new JSONArray();
		
		// add json snodes to sNodeList
		for (int i=0; i < snList.size(); i++) {
			sNodeList.add(snList.get(i).toJson());
		}
		
		ret.put("sNodeList", sNodeList);
		return ret;
	}
	
}
